% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{PyiUpdater Documentation}
\date{January 01, 2015}
\release{0.13.1-dev111713}
\author{Digital Sapphire}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{What is PyiUpdater?}
\label{index:welcome-to-pyiupdater}\label{index:what-is-pyiupdater}
In its simplest form PyiUpdater is a collection of modules, when used together, makes its super simple to add auto-update functionality to your app. Support for patch updates are included out of the box :)

A high level break down of the framework consists of 3 parts.
\begin{description}
\item[{Client}] \leavevmode
Is the module you import into your app that provides the update functionality. It also uses the Patcher module internally.

\item[{Core}] \leavevmode
Consists of the Archiver, Downloader, FileCrypt, KeyHandler, PackageHandler \& Utils.

\item[{CLI}] \leavevmode
Command line program to help automate the update creation process

\end{description}


\chapter{Status}
\label{index:status}
Starting with v0.9.2 PyiUpdater supports updating GUI \& cli apps on Mac, Windows \& Linux. The api is pretty stable but maintaining backwards compatibility is on a best effort basis until v1.0. Backwards incompatible changes will be noted in the changelog.

Contents:


\section{Downloads}
\label{downloads:downloads}\label{downloads::doc}\label{downloads:id1}

\subsection{Source Downloads:}
\label{downloads:source-downloads}
\href{https://github.com/JohnyMoSwag/PyiUpdater/zipball/master}{zip file}

\href{https://github.com/JohnyMoSwag/PyiUpdater/tarball/master}{tarball}


\section{Installation}
\label{installation:installation}\label{installation::doc}\label{installation:id1}
PyiUpdater depends on a few external libraries: \href{https://pypi.python.org/pypi/appdirs/}{appdirs}, \href{https://pypi.python.org/pypi/blinker}{blinker}, \href{http://aws.amazon.com/sdkforpython/}{boto},  \href{https://github.com/ilanschnell/bsdiff4}{bsdiff4}, \href{https://pypi.python.org/pypi/certifi}{certifi}, \href{https://pypi.python.org/pypi/ed25519}{ed25519}, \href{https://pypi.python.org/pypi/JMS-Utils}{jms\_utils} , \href{https://github.com/pyinstaller/pyinstaller}{pyinstaller}, \href{https://pypi.python.org/pypi/simple-pbkdf2}{simple\_pbkdf2}, \href{https://pypi.python.org/pypi/six}{six}, \href{https://pypi.python.org/pypi/stevedore}{stevedore} \& \href{https://pypi.python.org/pypi/urllib3}{urllib3}. Bsdiff4 is only required to make patches, not to apply them.  These libraries are not documented here.

So how do you get all that on your computer quickly?

Install from pip:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} pip install PyiUpdater \PYGZhy{}\PYGZhy{}process\PYGZhy{}dependency\PYGZhy{}links
\end{Verbatim}

S3 \& SCP upload plugins are available with:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} pip install PyiUpdater[s3] \PYGZhy{}\PYGZhy{}process\PYGZhy{}dependency\PYGZhy{}links

\PYGZdl{} pip install PyiUpdater[scp] \PYGZhy{}\PYGZhy{}process\PYGZhy{}dependency\PYGZhy{}links
\end{Verbatim}

If you want the bleeding edge download a pre-release version. WARNING! -\textgreater{} pre released version may not work as expected:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} pip install PyiUpdater \PYGZhy{}\PYGZhy{}pre \PYGZhy{}\PYGZhy{}process\PYGZhy{}dependency\PYGZhy{}links
\end{Verbatim}


\section{Configuration}
\label{configuration:configuration}\label{configuration::doc}\label{configuration:id1}
\begin{tabulary}{\linewidth}{|p{6.5cm}|p{8.5cm}|}
\hline

\code{APP\_NAME}
 & 
(str) Name of your app. Used with
COMPANY\_NAME to create an update cache dir on end user system.
\\

\code{COMPANY\_NAME}
 & 
(str) Company or your name.  Used with
APP\_NAME to create an update cache dir on end user system.
\\

\code{DEV\_DATA\_DIR}
 & 
(str) Full path to directory where
pyiupdater will keep work files. i.e signing
keys, src file for patch creation, etc.
\\

\code{PUBLIC\_KEY}
 & 
(tuple) Used on client side for
authentication
\\

\code{UPDATE\_URL}
 & 
(str) Where clients search for updates
- * Deprecated! You can put a single url
in the list of UPDATE\_URLS *
\\

\code{UPDATE\_URLS}
 & 
(list) A list of url(s) where a client will
look for needed update objects.
\\

\code{UPDATE\_PATCHES}
 & 
(bool) Enable/disable creation of patch
updates
\\

\code{REMOTE\_DIR}
 & 
(str) Remote directory/Bucket name to place
update files
\\

\code{HOST}
 & 
(str) Remote host to connect to for server
uploads
\\

\code{USERNAME}
 & 
(str) Username/API Key for uploading updates
\\
\hline\end{tabulary}



\section{Usage}
\label{usage:usage}\label{usage::doc}\label{usage:id1}
After compiling your program with pyinstaller or any freezer that compiles python into a single executable.

Use the Archiver Maker for easy update compression \& naming.

Version numbers are in the form of: x.x.x

Check \href{http://semver.org/}{Semantic Versioning} for more info

The easiest way to get started quickly is to use to command line tool. After setup is complete you'll be ready to start creating updates.

From a terminal:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} pyiupdater init
\end{Verbatim}


\subsection{Demos}
\label{usage:demos}
So if you opt not to use the cli interface \& instead want to integrate PyiUpdater into your build, look below.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{k+kn}{from} \PYG{n+nn}{pyi\PYGZus{}updater} \PYG{k+kn}{import} \PYG{n}{PyiUpdater}\PYG{p}{,} \PYG{n}{PyiUpdaterConfig}


\PYG{c}{\PYGZsh{} PyiUpdater handles configuration with simple}
\PYG{c}{\PYGZsh{} class attributes. They must be in all CAPS.}
\PYG{c}{\PYGZsh{} to be registered. You may pass in custom}
\PYG{c}{\PYGZsh{} settings to be used later.}
\PYG{k}{class} \PYG{n+nc}{DefaultConfig}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} If left None \PYGZdq{}PyiUpdater App\PYGZdq{} will be used}
    \PYG{n}{APP\PYGZus{}NAME} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{My New App}\PYG{l+s}{\PYGZdq{}}

    \PYG{n}{Company\PYGZus{}Name} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Acme}\PYG{l+s}{\PYGZdq{}}

    \PYG{c}{\PYGZsh{} Used for verion file signature verification}
    \PYG{c}{\PYGZsh{} base64 encoded ed25519 key}
    \PYG{n}{PUBLIC\PYGZus{}KEY} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{zZiCrUaXDwd9pT5FpjoeYCDfO8nBeZGPcpxIkRE2dXg}\PYG{l+s}{\PYGZsq{}}

    \PYG{n}{DEV\PYGZus{}DATA\PYGZus{}DIR} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{getcwd}\PYG{p}{(}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} Online repository where you host your packages}
    \PYG{c}{\PYGZsh{} and version file}
    \PYG{n}{UPDATE\PYGZus{}URL} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{https://acme.com/updates}\PYG{l+s}{\PYGZsq{}}
    \PYG{c}{\PYGZsh{} List of urls to check if version file \PYGZam{} update data}
    \PYG{c}{\PYGZsh{} For each object need the urls will be used in succession}
    \PYG{c}{\PYGZsh{} until the required object is found}
    \PYG{n}{UPDATE\PYGZus{}URLS} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{https://acme.com/updates}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
                   \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{https://mirror.acme.com/updates}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
                   \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{https://acme.amazon.com/updates}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
    \PYG{n}{UPDATE\PYGZus{}PATCHES} \PYG{o}{=} \PYG{n+nb+bp}{True}

    \PYG{c}{\PYGZsh{} This is a path on the remote server or bucket name}
    \PYG{c}{\PYGZsh{} on amazon s3}
    \PYG{n}{REMOTE\PYGZus{}DIR} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{my\PYGZhy{}new\PYGZhy{}bucket}\PYG{l+s}{\PYGZdq{}}

    \PYG{c}{\PYGZsh{} The url or ip to remote host server.}
    \PYG{c}{\PYGZsh{} Mostly for scp uploads}
    \PYG{n}{HOST} \PYG{o}{=} \PYG{n+nb+bp}{None}

    \PYG{c}{\PYGZsh{} Username or access ID}
    \PYG{n}{USERNAME} \PYG{o}{=} \PYG{n+nb+bp}{None}

    \PYG{c}{\PYGZsh{} Password or path to keyfile if using scp}
    \PYG{n}{PASSWORD} \PYG{o}{=} \PYG{n+nb+bp}{None}


\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} Setting up Config object}
    \PYG{n}{default\PYGZus{}config} \PYG{o}{=} \PYG{n}{DefaultConfig}\PYG{p}{(}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} Initilizing Main object and configuring}
    \PYG{c}{\PYGZsh{} in one step}
    \PYG{n}{pyiu\PYGZus{}config} \PYG{o}{=} \PYG{n}{PyiUpdaterConfig}\PYG{p}{(}\PYG{n}{DefaultConfig}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} Can also update config later}
    \PYG{n}{pyiu\PYGZus{}config}\PYG{o}{.}\PYG{n}{update\PYGZus{}config}\PYG{p}{(}\PYG{n}{default\PYGZus{}config}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} Initializing PyiUpdater with config info}
    \PYG{n}{pyiu} \PYG{o}{=} \PYG{n}{PyiUpdater}\PYG{p}{(}\PYG{n}{pyiu\PYGZus{}config}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} Can also be Initilized without config}
    \PYG{n}{pyiu} \PYG{o}{=} \PYG{n}{PyiUpdater}\PYG{p}{(}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} Then update later with config}
    \PYG{n}{pyiu}\PYG{o}{.}\PYG{n}{update\PYGZus{}config}\PYG{p}{(}\PYG{n}{pyiu\PYGZus{}config}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} Setting up work directories}
    \PYG{c}{\PYGZsh{} Only need to run once on a new project but it\PYGZsq{}s}
    \PYG{c}{\PYGZsh{} ok if ran multipule times}
    \PYG{n}{pyiu}\PYG{o}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{pyiu}\PYG{o}{.}\PYG{n}{make\PYGZus{}keys}\PYG{p}{(}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} Now place new packages in the folder named}
    \PYG{c}{\PYGZsh{} \PYGZdq{}new\PYGZdq{} in the pyi\PYGZhy{}data directory}
    \PYG{c}{\PYGZsh{} Package Archive filename should be in the form}
    \PYG{c}{\PYGZsh{} AppName\PYGZhy{}platform\PYGZhy{}version.zip}
    \PYG{n+nb}{raw\PYGZus{}input}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Place updates in new folder then press enter.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} This updates the version file with the}
    \PYG{c}{\PYGZsh{} new packages \PYGZam{} moves them to the deploy folder.}
    \PYG{n}{pyiu}\PYG{o}{.}\PYG{n}{process\PYGZus{}packages}\PYG{p}{(}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} This signs the update manifest \PYGZam{} copies it}
    \PYG{c}{\PYGZsh{} to the deploy folder}
    \PYG{n}{pyiu}\PYG{o}{.}\PYG{n}{sign\PYGZus{}update}\PYG{p}{(}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} Load desired uploader}
    \PYG{k}{try}\PYG{p}{:}
        \PYG{n}{pyiu}\PYG{o}{.}\PYG{n}{set\PYGZus{}uploader}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{s3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{pyiu}\PYG{o}{.}\PYG{n}{upload}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{except}\PYG{p}{:}
        \PYG{c}{\PYGZsh{} Make sure you have the requested uploader installed}
        \PYG{c}{\PYGZsh{} pyiupdater[\PYGZsq{}s3\PYGZsq{}] for Amazon S3}
        \PYG{c}{\PYGZsh{} pyiupdater[\PYGZsq{}scp\PYGZsq{}] for server uploads}
        \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{upload failed}\PYG{l+s}{\PYGZsq{}}

\PYG{k}{if} \PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\section{Architecture}
\label{architecture::doc}\label{architecture:architecture}\label{architecture:id1}
Archiver
\begin{quote}

More info coming
\end{quote}

Client
\begin{quote}

More info coming
\end{quote}

Config
\begin{quote}

More info coming
\end{quote}

Downloader
\begin{quote}

More info coming
\end{quote}

FileCrypt
\begin{quote}

More info coming
\end{quote}

KeyHandler
\begin{quote}

More info coming
\end{quote}

PackageHandler
\begin{quote}

More info coming
\end{quote}

Patcher
\begin{quote}

More info coming
\end{quote}

Utils
\begin{quote}

More info coming
\end{quote}


\section{File \& Folder Structure}
\label{folder_structure::doc}\label{folder_structure:file-folder-structure}

\subsection{Program Src Directory}
\label{folder_structure:program-src-directory}\begin{quote}

- pyi-data
\begin{quote}

- new

- deploy

- files
\begin{quote}

- most recent updates
\end{quote}

- version.json
\end{quote}

- .pyiupdater
\begin{quote}

- config.data

- data.json

- keys
\end{quote}
\end{quote}


\subsubsection{File \& Folder Explanations}
\label{folder_structure:file-folder-explanations}
New: Where you place newly compiled programs ready for signing

Deploy: After updates have been signed, they'll be moved here with an updated version file

Files: Holds most recent update for each file

version.json: Version info for updates

config.data: Config information for app

data.json: PyiUpdater config information

Keys: Your public and private keys


\section{Contributing}
\label{contributing:contributing}\label{contributing::doc}\label{contributing:id1}
All contributions are welcome.

Since PyiUpdater is close to v1.0 the goal is to make it as stable as possible. So for the time being no pull requests will be accepted that add new features until PyiUpdater is out of beta.

Fixing bugs \& filing issues are very welcome \& encouraged.


\subsection{Code Style}
\label{contributing:code-style}
Let's try to stick to pep 8 as much as possible.


\section{API}
\label{api:api}\label{api::doc}
If you want to dive into their documentation, scroll down:
\phantomsection\label{api:module-pyi_updater}\index{pyi\_updater (module)}\index{PyiUpdater (class in pyi\_updater)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.PyiUpdater}\pysiglinewithargsret{\strong{class }\code{pyi\_updater.}\bfcode{PyiUpdater}}{\emph{config=None}}{}
Processes, signs \& uploads updates

Kwargs:
\begin{quote}

config (obj): config object
\end{quote}
\index{update\_config() (pyi\_updater.PyiUpdater method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.PyiUpdater.update_config}\pysiglinewithargsret{\bfcode{update\_config}}{\emph{config}}{}
Updates internal config

Args:
\begin{quote}

config (obj): config object
\end{quote}

\end{fulllineitems}

\index{setup() (pyi\_updater.PyiUpdater method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.PyiUpdater.setup}\pysiglinewithargsret{\bfcode{setup}}{}{}
Sets up root dir with required PyiUpdater folders

\end{fulllineitems}

\index{process\_packages() (pyi\_updater.PyiUpdater method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.PyiUpdater.process_packages}\pysiglinewithargsret{\bfcode{process\_packages}}{}{}
Creates hash for updates \& adds information about update to
version file

\end{fulllineitems}

\index{set\_uploader() (pyi\_updater.PyiUpdater method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.PyiUpdater.set_uploader}\pysiglinewithargsret{\bfcode{set\_uploader}}{\emph{requested\_uploader}}{}
Sets upload destination

Args:
\begin{quote}

requested\_uploader (str): upload service. i.e. s3, scp
\end{quote}

\end{fulllineitems}

\index{upload() (pyi\_updater.PyiUpdater method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.PyiUpdater.upload}\pysiglinewithargsret{\bfcode{upload}}{}{}
Uploads files in deploy folder

\end{fulllineitems}

\index{make\_keys() (pyi\_updater.PyiUpdater method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.PyiUpdater.make_keys}\pysiglinewithargsret{\bfcode{make\_keys}}{}{}
Creates signing keys

\end{fulllineitems}

\index{sign\_update() (pyi\_updater.PyiUpdater method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.PyiUpdater.sign_update}\pysiglinewithargsret{\bfcode{sign\_update}}{}{}
Signs version file with signing key

\end{fulllineitems}

\index{get\_public\_key() (pyi\_updater.PyiUpdater method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.PyiUpdater.get_public_key}\pysiglinewithargsret{\bfcode{get\_public\_key}}{}{}
Returns public key

\end{fulllineitems}

\index{print\_public\_key() (pyi\_updater.PyiUpdater method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.PyiUpdater.print_public_key}\pysiglinewithargsret{\bfcode{print\_public\_key}}{}{}
Prints public key to console

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{api:module-pyi_updater.client}\index{pyi\_updater.client (module)}\index{Client (class in pyi\_updater.client)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.client.Client}\pysiglinewithargsret{\strong{class }\code{pyi\_updater.client.}\bfcode{Client}}{\emph{obj=None}, \emph{refresh=False}, \emph{test=False}}{}
Used on client side to update files

Kwargs:
\begin{quote}

obj (instance): config object

refresh (bool) Meaning:
\begin{quote}

True: Refresh update manifest on object initialization

False: Don't refresh update manifest on object initialization
\end{quote}
\end{quote}
\index{init\_app() (pyi\_updater.client.Client method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.client.Client.init_app}\pysiglinewithargsret{\bfcode{init\_app}}{\emph{obj}, \emph{refresh=True}, \emph{test=False}}{}
Sets up client with config values from obj

Args:
\begin{quote}

obj (instance): config object
\end{quote}

\end{fulllineitems}

\index{refresh() (pyi\_updater.client.Client method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.client.Client.refresh}\pysiglinewithargsret{\bfcode{refresh}}{}{}
Will download and verify your updates version file.

Proxy method from \code{\_get\_update\_manifest()}.

\end{fulllineitems}

\index{update\_check() (pyi\_updater.client.Client method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.client.Client.update_check}\pysiglinewithargsret{\bfcode{update\_check}}{\emph{name}, \emph{version}}{}
Will try to patch binary if all check pass.  IE hash verified
signature verified.  If any check doesn't pass then falls back to
full update

Args:
\begin{quote}

name (str): Name of file to update

version (str): Current version number of file to update
\end{quote}

Returns:
\begin{quote}

(bool) Meanings:
\begin{quote}

True - Update Successful

False - Update Failed
\end{quote}
\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{api:module-pyi_updater.client.updates}\index{pyi\_updater.client.updates (module)}\index{LibUpdate (class in pyi\_updater.client.updates)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.client.updates.LibUpdate}\pysiglinewithargsret{\strong{class }\code{pyi\_updater.client.updates.}\bfcode{LibUpdate}}{\emph{data}}{}
Used to update library files used by an application

Args:
\begin{quote}

data (dict): Info dict
\end{quote}
\index{download() (pyi\_updater.client.updates.LibUpdate method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.client.updates.LibUpdate.download}\pysiglinewithargsret{\bfcode{download}}{}{}
Will download the package update that was referenced
with check update.

Proxy method for \code{\_patch\_update()} \& \code{\_full\_update()}.

Returns:
\begin{quote}

(bool) Meanings:
\begin{quote}

True - Download successful

False - Download failed
\end{quote}
\end{quote}

\end{fulllineitems}

\index{extract() (pyi\_updater.client.updates.LibUpdate method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.client.updates.LibUpdate.extract}\pysiglinewithargsret{\bfcode{extract}}{}{}
Will extract archived update and leave in update folder.
If updating a lib you can take over from there. If updating
an app this call should be followed by \code{restart()} to
complete update.

Proxy method for \code{\_extract\_update()}.

Returns:
\begin{quote}

(bool) Meanings:
\begin{quote}

True - Install successful

False - Install failed
\end{quote}
\end{quote}

\end{fulllineitems}

\index{install() (pyi\_updater.client.updates.LibUpdate method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.client.updates.LibUpdate.install}\pysiglinewithargsret{\bfcode{install}}{}{}
DEPRECATED! Proxy method for {\hyperref[api:pyi_updater.client.updates.LibUpdate.extract]{\code{extract()}}}.

\end{fulllineitems}


\end{fulllineitems}

\index{AppUpdate (class in pyi\_updater.client.updates)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.client.updates.AppUpdate}\pysiglinewithargsret{\strong{class }\code{pyi\_updater.client.updates.}\bfcode{AppUpdate}}{\emph{data}}{}
Used to update library files used by an application

Args:
\begin{quote}

data (dict): Info dict
\end{quote}
\index{extract\_restart() (pyi\_updater.client.updates.AppUpdate method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.client.updates.AppUpdate.extract_restart}\pysiglinewithargsret{\bfcode{extract\_restart}}{}{}
Will extract the update, overwrite the current app,
then restart the app using the updated binary.

On windows Proxy method for \code{\_extract\_update()} \&
\code{\_win\_overwrite\_app\_restart()}

On unix Proxy method for \code{\_extract\_update()},
\code{\_overwrite\_app()} \& \code{\_restart()}

\end{fulllineitems}

\index{install\_restart() (pyi\_updater.client.updates.AppUpdate method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.client.updates.AppUpdate.install_restart}\pysiglinewithargsret{\bfcode{install\_restart}}{}{}
DEPRECATED!  Proxy method for {\hyperref[api:pyi_updater.client.updates.AppUpdate.extract_restart]{\code{extract\_restart()}}}.

\end{fulllineitems}

\index{restart() (pyi\_updater.client.updates.AppUpdate method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.client.updates.AppUpdate.restart}\pysiglinewithargsret{\bfcode{restart}}{}{}
Will overwrite old binary with updated binary and
restart using the updated binary. Not supported on windows.

Proxy method for \code{\_overwrite\_app()} \& \code{\_restart()}.

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{api:module-pyi_updater.client.utils}\index{pyi\_updater.client.utils (module)}\index{get\_mac\_dot\_app\_dir() (in module pyi\_updater.client.utils)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.client.utils.get_mac_dot_app_dir}\pysiglinewithargsret{\code{pyi\_updater.client.utils.}\bfcode{get\_mac\_dot\_app\_dir}}{\emph{directory}}{}
Returns parent directory of mac .app

Args:
\begin{quote}

directory (str): Current directory
\end{quote}

Returns:
\begin{quote}

(str): Parent directory of mac .app
\end{quote}

\end{fulllineitems}

\index{get\_highest\_version() (in module pyi\_updater.client.utils)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.client.utils.get_highest_version}\pysiglinewithargsret{\code{pyi\_updater.client.utils.}\bfcode{get\_highest\_version}}{\emph{name}, \emph{plat}, \emph{easy\_data}}{}
Parses version file and returns the highest version number.

Args:
\begin{quote}

name (str): name of file to search for updates

easy\_data (dict): data file to search
\end{quote}

Returns:
\begin{quote}

(str) Highest version number
\end{quote}

\end{fulllineitems}

\index{get\_filename() (in module pyi\_updater.client.utils)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.client.utils.get_filename}\pysiglinewithargsret{\code{pyi\_updater.client.utils.}\bfcode{get\_filename}}{\emph{name}, \emph{version}, \emph{platform}, \emph{easy\_data}}{}
Gets full filename for given name \& version combo

Args:
\begin{quote}

name (str): name of file to get full filename for

version (str): version of file to get full filename for

easy\_data (dict): data file to search
\end{quote}

Returns:
\begin{quote}

(str) Filename with extension
\end{quote}

\end{fulllineitems}

\phantomsection\label{api:module-pyi_updater.config}\index{pyi\_updater.config (module)}\index{Loader (class in pyi\_updater.config)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.config.Loader}\pysigline{\strong{class }\code{pyi\_updater.config.}\bfcode{Loader}}
Loads \&  saves config file
\index{load\_config() (pyi\_updater.config.Loader method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.config.Loader.load_config}\pysiglinewithargsret{\bfcode{load\_config}}{}{}
Load config file from file system

\end{fulllineitems}

\index{save\_config() (pyi\_updater.config.Loader method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.config.Loader.save_config}\pysiglinewithargsret{\bfcode{save\_config}}{\emph{obj}}{}
Saves config file to file system

Args:
\begin{quote}

obj (obj): config object
\end{quote}

\end{fulllineitems}

\index{write\_config\_py() (pyi\_updater.config.Loader method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.config.Loader.write_config_py}\pysiglinewithargsret{\bfcode{write\_config\_py}}{\emph{obj}}{}
Writes client config to client\_config.py

Args:
\begin{quote}

obj (obj): config object
\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{PyiUpdaterConfig (class in pyi\_updater.config)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.config.PyiUpdaterConfig}\pysiglinewithargsret{\strong{class }\code{pyi\_updater.config.}\bfcode{PyiUpdaterConfig}}{\emph{obj=None}}{}
Works exactly like a dict but provides ways to fill it from files
or special dictionaries.  There are two common patterns to populate the
config.

You can define the configuration options in the
module that calls {\hyperref[api:pyi_updater.config.PyiUpdaterConfig.from_object]{\code{from\_object()}}}.  It is also possible to tell it
to use the same module and with that provide the configuration values
just before the call.

Loading from modules, only uppercase keys are added to the config.
This makes it possible to use lowercase values in the config file for
temporary values that are not added to the config or to define the config
keys in the same file that implements the application.
\index{from\_object() (pyi\_updater.config.PyiUpdaterConfig method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.config.PyiUpdaterConfig.from_object}\pysiglinewithargsret{\bfcode{from\_object}}{\emph{obj}}{}
Updates the values from the given object

Args:
\begin{quote}

obj (instance): Object with config attributes
\end{quote}

Objects are classes.

Just the uppercase variables in that object are stored in the config.
Example usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{yourapplication} \PYG{k+kn}{import} \PYG{n}{default\PYGZus{}config}
\PYG{n}{app}\PYG{o}{.}\PYG{n}{config}\PYG{o}{.}\PYG{n}{from\PYGZus{}object}\PYG{p}{(}\PYG{n}{default\PYGZus{}config}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{update\_config() (pyi\_updater.config.PyiUpdaterConfig method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.config.PyiUpdaterConfig.update_config}\pysiglinewithargsret{\bfcode{update\_config}}{\emph{obj}}{}
Proxy method to update self

Args:
\begin{quote}

obj (instance): config object
\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SetupConfig (class in pyi\_updater.config)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.config.SetupConfig}\pysigline{\strong{class }\code{pyi\_updater.config.}\bfcode{SetupConfig}}
Default config object

\end{fulllineitems}

\phantomsection\label{api:module-pyi_updater.downloader}\index{pyi\_updater.downloader (module)}\index{FileDownloader (class in pyi\_updater.downloader)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.downloader.FileDownloader}\pysiglinewithargsret{\strong{class }\code{pyi\_updater.downloader.}\bfcode{FileDownloader}}{\emph{filename}, \emph{urls}, \emph{hexdigest=None}, \emph{verify=True}}{}
The FileDownloader object downloads files to memory and
verifies their hash.  If hash is verified data is either
written to disk to returned to calling object

Args:
\begin{quote}

filename (str): The name of file to download

urls (list): List of urls to use for file download
\end{quote}

Kwargs:
\begin{quote}

hexdigest (str): The hash of the file to download

verify (bool) Meaning:
\begin{quote}

True: Verify https connection

False: Don't verify https connection
\end{quote}
\end{quote}
\index{download\_verify\_write() (pyi\_updater.downloader.FileDownloader method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.downloader.FileDownloader.download_verify_write}\pysiglinewithargsret{\bfcode{download\_verify\_write}}{}{}
Downloads file then verifies against provided hash
If hash verfies then writes data to disk

Returns:
\begin{quote}

(bool) Meanings:
\begin{quote}

True - Hash verified

False - Hash not verified
\end{quote}
\end{quote}

\end{fulllineitems}

\index{download\_verify\_return() (pyi\_updater.downloader.FileDownloader method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.downloader.FileDownloader.download_verify_return}\pysiglinewithargsret{\bfcode{download\_verify\_return}}{}{}
Downloads file to memory, checks against provided hash
If matched returns binary data

Returns:
\begin{quote}

(data) Meanings:
\begin{quote}

Data - If everything verified

None - If any verification didn't pass
\end{quote}
\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{api:module-pyi_updater.exceptions}\index{pyi\_updater.exceptions (module)}\index{STDError}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.exceptions.STDError}\pysiglinewithargsret{\strong{exception }\code{pyi\_updater.exceptions.}\bfcode{STDError}}{\emph{msg}, \emph{tb=None}, \emph{expected=False}}{}
Extends exceptions to show added message if error isn't expected.

Args:
\begin{quote}

msg (str): error message
\end{quote}

Kwargs:
\begin{quote}

tb (obj): is the original traceback so that it can be printed.

expected (bool): Meaning:
\begin{quote}

True - Report issue msg not shown

False - Report issue msg shown
\end{quote}
\end{quote}

\end{fulllineitems}

\index{ArchiverError}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.exceptions.ArchiverError}\pysiglinewithargsret{\strong{exception }\code{pyi\_updater.exceptions.}\bfcode{ArchiverError}}{\emph{*args}, \emph{**kwargs}}{}
Raised for Archiver exceptions

\end{fulllineitems}

\index{ClientError}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.exceptions.ClientError}\pysiglinewithargsret{\strong{exception }\code{pyi\_updater.exceptions.}\bfcode{ClientError}}{\emph{*args}, \emph{**kwargs}}{}
Raised for Client exceptions

\end{fulllineitems}

\index{ConfigError}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.exceptions.ConfigError}\pysiglinewithargsret{\strong{exception }\code{pyi\_updater.exceptions.}\bfcode{ConfigError}}{\emph{*args}, \emph{**kwargs}}{}
Raised for Config exceptions

\end{fulllineitems}

\index{FileDownloaderError}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.exceptions.FileDownloaderError}\pysiglinewithargsret{\strong{exception }\code{pyi\_updater.exceptions.}\bfcode{FileDownloaderError}}{\emph{*args}, \emph{**kwargs}}{}
Raised for FileDownloader exceptions

\end{fulllineitems}

\index{KeyHandlerError}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.exceptions.KeyHandlerError}\pysiglinewithargsret{\strong{exception }\code{pyi\_updater.exceptions.}\bfcode{KeyHandlerError}}{\emph{*args}, \emph{**kwargs}}{}
Raised for KeyHandler exceptions

\end{fulllineitems}

\index{PackageError}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.exceptions.PackageError}\pysiglinewithargsret{\strong{exception }\code{pyi\_updater.exceptions.}\bfcode{PackageError}}{\emph{*args}, \emph{**kwargs}}{}
Raised for Package exceptions

\end{fulllineitems}

\index{PackageHandlerError}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.exceptions.PackageHandlerError}\pysiglinewithargsret{\strong{exception }\code{pyi\_updater.exceptions.}\bfcode{PackageHandlerError}}{\emph{*args}, \emph{**kwargs}}{}
Raised for PackageHandler exceptions

\end{fulllineitems}

\index{PatcherError}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.exceptions.PatcherError}\pysiglinewithargsret{\strong{exception }\code{pyi\_updater.exceptions.}\bfcode{PatcherError}}{\emph{*args}, \emph{**kwargs}}{}
Raised for Patcher exceptions

\end{fulllineitems}

\index{PyiUpdaterError}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.exceptions.PyiUpdaterError}\pysiglinewithargsret{\strong{exception }\code{pyi\_updater.exceptions.}\bfcode{PyiUpdaterError}}{\emph{*args}, \emph{**kwargs}}{}
Raised for Framework exceptions

\end{fulllineitems}

\index{UpdaterError}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.exceptions.UpdaterError}\pysiglinewithargsret{\strong{exception }\code{pyi\_updater.exceptions.}\bfcode{UpdaterError}}{\emph{*args}, \emph{**kwargs}}{}
Raised for Updater exceptions

\end{fulllineitems}

\index{UploaderError}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.exceptions.UploaderError}\pysiglinewithargsret{\strong{exception }\code{pyi\_updater.exceptions.}\bfcode{UploaderError}}{\emph{*args}, \emph{**kwargs}}{}
Raised for Uploader exceptions

\end{fulllineitems}

\index{UtilsError}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.exceptions.UtilsError}\pysiglinewithargsret{\strong{exception }\code{pyi\_updater.exceptions.}\bfcode{UtilsError}}{\emph{*args}, \emph{**kwargs}}{}
Raised for Utils exceptions

\end{fulllineitems}

\phantomsection\label{api:module-pyi_updater.key_handler}\index{pyi\_updater.key\_handler (module)}\index{KeyHandler (class in pyi\_updater.key\_handler)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.key_handler.KeyHandler}\pysiglinewithargsret{\strong{class }\code{pyi\_updater.key\_handler.}\bfcode{KeyHandler}}{\emph{app=None}}{}
KeyHanlder object is used to manage keys used for signing updates

Kwargs:
\begin{quote}

app (obj): Config object to get config values from
\end{quote}
\index{init\_app() (pyi\_updater.key\_handler.KeyHandler method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.key_handler.KeyHandler.init_app}\pysiglinewithargsret{\bfcode{init\_app}}{\emph{obj}}{}
Sets up client with config values from obj

Args:
\begin{quote}

obj (instance): config object
\end{quote}

\end{fulllineitems}

\index{make\_keys() (pyi\_updater.key\_handler.KeyHandler method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.key_handler.KeyHandler.make_keys}\pysiglinewithargsret{\bfcode{make\_keys}}{\emph{overwrite=False}}{}
Makes public and private keys for signing and verification

Kwargs:
\begin{quote}

overwrite (bool): Determines if existing keys are overwritten
\end{quote}

\end{fulllineitems}

\index{sign\_update() (pyi\_updater.key\_handler.KeyHandler method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.key_handler.KeyHandler.sign_update}\pysiglinewithargsret{\bfcode{sign\_update}}{}{}
Signs version file with private key

Proxy method for \code{\_load\_private\_key()}, \code{\_add\_sig()} \&
\code{\_write\_update\_data()}

\end{fulllineitems}

\index{get\_public\_key() (pyi\_updater.key\_handler.KeyHandler method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.key_handler.KeyHandler.get_public_key}\pysiglinewithargsret{\bfcode{get\_public\_key}}{}{}
Returns (object): Public Key

\end{fulllineitems}

\index{print\_public\_key() (pyi\_updater.key\_handler.KeyHandler method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.key_handler.KeyHandler.print_public_key}\pysiglinewithargsret{\bfcode{print\_public\_key}}{}{}
Prints public key data to console

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{api:module-pyi_updater.package_handler}\index{pyi\_updater.package\_handler (module)}\index{PackageHandler (class in pyi\_updater.package\_handler)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.package_handler.PackageHandler}\pysiglinewithargsret{\strong{class }\code{pyi\_updater.package\_handler.}\bfcode{PackageHandler}}{\emph{app=None}}{}
Handles finding, sorting, getting meta-data, moving packages.

Kwargs:
\begin{quote}

app (instance): Config object
\end{quote}
\index{init\_app() (pyi\_updater.package\_handler.PackageHandler method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.package_handler.PackageHandler.init_app}\pysiglinewithargsret{\bfcode{init\_app}}{\emph{obj}}{}
Sets up client with config values from obj

Args:
\begin{quote}

obj (instance): config object
\end{quote}

\end{fulllineitems}

\index{setup() (pyi\_updater.package\_handler.PackageHandler method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.package_handler.PackageHandler.setup}\pysiglinewithargsret{\bfcode{setup}}{}{}
Creates working directories \& loads json files.

Proxy method for \code{\_setup\_work\_dirs()} \& \code{\_load\_version\_file()}

\end{fulllineitems}

\index{process\_packages() (pyi\_updater.package\_handler.PackageHandler method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.package_handler.PackageHandler.process_packages}\pysiglinewithargsret{\bfcode{process\_packages}}{}{}
Gets a list of updates to process.  Adds the name of an
update to the version file if not already present.  Processes
all packages.  Updates the version file meta-data. Then writes
version file back to disk.

Proxy method for \code{\_get\_package\_list()},
\code{\_make\_patches()}, \code{\_add\_patches\_to\_packages()},
\code{\_update\_version\_file()},
\code{\_write\_json\_to\_file()} \& \code{\_move\_packages()}.

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{api:module-pyi_updater.package_handler.package}\index{pyi\_updater.package\_handler.package (module)}\index{Patch (class in pyi\_updater.package\_handler.package)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.package_handler.package.Patch}\pysiglinewithargsret{\strong{class }\code{pyi\_updater.package\_handler.package.}\bfcode{Patch}}{\emph{patch\_info}}{}
Holds information for patch file.

Args:
\begin{quote}

patch\_info (dict): patch information
\end{quote}

\end{fulllineitems}

\index{Package (class in pyi\_updater.package\_handler.package)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.package_handler.package.Package}\pysiglinewithargsret{\strong{class }\code{pyi\_updater.package\_handler.package.}\bfcode{Package}}{\emph{filename}}{}
Holds information of update file.

Args:
\begin{quote}

filename (str): name of update file
\end{quote}
\index{extract\_info() (pyi\_updater.package\_handler.package.Package method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.package_handler.package.Package.extract_info}\pysiglinewithargsret{\bfcode{extract\_info}}{\emph{package}}{}
Gets version number, platform \& hash for package.

Args:
\begin{quote}

package (str): filename
\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{api:module-pyi_updater.patcher}\index{pyi\_updater.patcher (module)}\index{Patcher (class in pyi\_updater.patcher)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.patcher.Patcher}\pysiglinewithargsret{\strong{class }\code{pyi\_updater.patcher.}\bfcode{Patcher}}{\emph{**kwargs}}{}
Downloads, verifies, and patches binaries

Kwargs:
\begin{quote}

name (str): Name of binary to patch

json\_data (dict): Info dict with all package meta data

current\_version (str): Version number of currently installed binary

highest\_version (str): Newest version available

update\_folder (str): Path to update folder to place updated binary in

update\_urls (list): List of urls to use for file download

verify (bool) Meaning:
\begin{quote}

True: Verify https connection

False: Don't verify https connection
\end{quote}
\end{quote}
\index{start() (pyi\_updater.patcher.Patcher method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.patcher.Patcher.start}\pysiglinewithargsret{\bfcode{start}}{}{}
Starts patching process

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{api:module-pyi_updater.utils}\index{pyi\_updater.utils (module)}\index{bsdiff4\_py (class in pyi\_updater.utils)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.utils.bsdiff4_py}\pysigline{\strong{class }\code{pyi\_updater.utils.}\bfcode{bsdiff4\_py}}
Pure-python version of bsdiff4 module that can only patch, not diff.

By providing a pure-python fallback, we don't force frozen apps to
bundle the bsdiff module in order to make use of patches.  Besides,
the patch-applying algorithm is very simple.

\end{fulllineitems}

\index{make\_archive() (in module pyi\_updater.utils)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.utils.make_archive}\pysiglinewithargsret{\code{pyi\_updater.utils.}\bfcode{make\_archive}}{\emph{name}, \emph{version}, \emph{target}}{}
Used to make archives of file or dir. Zip on windows and tar.gz
on all other platforms
\begin{description}
\item[{Args:}] \leavevmode
name - Name of app. Used to create final archive name

version - Version of app. Used to create final archive name

target - name of actual target file or dir.

\item[{Returns:}] \leavevmode
(str) - name of archive

\end{description}

\end{fulllineitems}

\index{ask\_yes\_no() (in module pyi\_updater.utils)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.utils.ask_yes_no}\pysiglinewithargsret{\code{pyi\_updater.utils.}\bfcode{ask\_yes\_no}}{\emph{question}, \emph{default='no'}, \emph{answer=None}}{}
Will ask a question and keeps prompting until
answered.
\begin{description}
\item[{Args:}] \leavevmode
question (str): Question to ask end user

\item[{Kwargs:}] \leavevmode
default (str): Default answer if user just press enter at prompt

\item[{Returns:}] \leavevmode
bool. Meaning:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{True} \PYG{o}{\PYGZhy{}} \PYG{n}{Answer} \PYG{o+ow}{is}  \PYG{n}{yes}

\PYG{n+nb+bp}{False} \PYG{o}{\PYGZhy{}} \PYG{n}{Answer} \PYG{o+ow}{is} \PYG{n}{no}
\end{Verbatim}

\end{description}

\end{fulllineitems}

\phantomsection\label{api:module-pyi_updater.uploader}\index{pyi\_updater.uploader (module)}\index{Uploader (class in pyi\_updater.uploader)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.uploader.Uploader}\pysiglinewithargsret{\strong{class }\code{pyi\_updater.uploader.}\bfcode{Uploader}}{\emph{app=None}}{}
Uploads updates to configured servers.  SSH, SFTP, S3
Will automatically pick the correct uploader depending on
what is configured thorough the config object

Sets up client with config values from obj
\begin{quote}

Args:
\begin{quote}

obj (instance): config object
\end{quote}
\end{quote}
\index{init\_app() (pyi\_updater.uploader.Uploader method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.uploader.Uploader.init_app}\pysiglinewithargsret{\bfcode{init\_app}}{\emph{obj}}{}
Sets up client with config values from obj

Args:
\begin{quote}

obj (instance): config object
\end{quote}

\end{fulllineitems}

\index{upload() (pyi\_updater.uploader.Uploader method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.uploader.Uploader.upload}\pysiglinewithargsret{\bfcode{upload}}{}{}
Proxy function that calls the upload method on the received uploader
Only calls the upload method if an uploader is set.

\end{fulllineitems}

\index{set\_uploader() (pyi\_updater.uploader.Uploader method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.uploader.Uploader.set_uploader}\pysiglinewithargsret{\bfcode{set\_uploader}}{\emph{requested\_uploader}}{}
Returns an uploader object. 1 of S3, SCP, SFTP.
SFTP uploaders not supported at this time.

Args:
\begin{quote}

requested\_uploader (string): Either s3 or scp
\end{quote}

Returns:
\begin{quote}

object (instance): Uploader object
\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{api:module-pyi_updater.uploader.common}\index{pyi\_updater.uploader.common (module)}\index{BaseUploader (class in pyi\_updater.uploader.common)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.uploader.common.BaseUploader}\pysigline{\strong{class }\code{pyi\_updater.uploader.common.}\bfcode{BaseUploader}}
Base Uploader.  All uploaders should subclass
this base class
\index{init() (pyi\_updater.uploader.common.BaseUploader method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.uploader.common.BaseUploader.init}\pysiglinewithargsret{\bfcode{init}}{\emph{**Kwargs}}{}
Used to initialize your plugin with username,
password, file list, remote\_dir/bucket \& host.
self.\_connect should be called after you grab all the
info you need.

Kwargs:
\begin{quote}

file\_list (list): List of files to upload

host (str): Either ip or domain name of remote servers

bucket\_name/remote\_dir (str): Remote location for update

remote\_dir (str): The directory on remote server to upload files to

username/aws\_access\_id (str): login for service

password/ssh\_key\_file/aws\_secret\_key (str): login for service
\end{quote}

\end{fulllineitems}

\index{upload() (pyi\_updater.uploader.common.BaseUploader method)}

\begin{fulllineitems}
\phantomsection\label{api:pyi_updater.uploader.common.BaseUploader.upload}\pysiglinewithargsret{\bfcode{upload}}{}{}
Uploads all files in file\_list

\end{fulllineitems}


\end{fulllineitems}



\section{License}
\label{license::doc}\label{license:license}\label{license:id1}
Copyright 2014 Digital Sapphire Development Team

Licensed under the Apache License, Version 2.0 (the ``License'');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
\begin{quote}

\href{http://www.apache.org/licenses/LICENSE-2.0}{http://www.apache.org/licenses/LICENSE-2.0}
\end{quote}

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ``AS IS'' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.


\section{Release History}
\label{release_history::doc}\label{release_history:release-history}

\subsection{v0.13.0 - 2014/12/27}
\label{release_history:v0-13-0-2014-12-27}

\subsubsection{Backwards incompatible release}
\label{release_history:backwards-incompatible-release}

\subsubsection{Demos have been update with the changes. Also its very important to make a decrypted copy of your config file before updating.}
\label{release_history:demos-have-been-update-with-the-changes-also-its-very-important-to-make-a-decrypted-copy-of-your-config-file-before-updating}\begin{itemize}
\item {} 
Updated
\begin{itemize}
\item {} 
CLI
\begin{itemize}
\item {} 
Updated with subcommands

\item {} 
pyiupdater -h

\item {} 
pyiupdater sub\_command -h

\end{itemize}

\item {} 
Client
\begin{itemize}
\item {} 
Fixed error when version numbers are correct in version file

\end{itemize}

\item {} 
KeyHandler
\begin{itemize}
\item {} 
Moved key storage to .pyiupdater folder

\end{itemize}

\item {} 
PyiUpdater
\begin{itemize}
\item {} 
Simplified config

\end{itemize}

\end{itemize}

\item {} 
Fixed
\begin{itemize}
\item {} 
PyiUpdater
\begin{itemize}
\item {} 
Logging when pyi.log is next to Mac .app bundles

\end{itemize}

\end{itemize}

\item {} 
Removed
\begin{itemize}
\item {} 
Client
\begin{itemize}
\item {} 
Redundant code

\end{itemize}

\item {} 
FileCrypt
\begin{itemize}
\item {} 
Passwords for remote locations will need to be set as env vars

\end{itemize}

\item {} 
PyiUpdater
\begin{itemize}
\item {} 
Redundant system calls

\end{itemize}

\item {} 
TUI
\begin{itemize}
\item {} 
Removed in favor of cli

\end{itemize}

\end{itemize}

\end{itemize}


\subsection{v0.12.3 - 2014/12/7}
\label{release_history:v0-12-3-2014-12-7}\begin{itemize}
\item {} 
Updated
\begin{itemize}
\item {} 
Client
\begin{itemize}
\item {} 
Handling version numbers passed to update\_check

\end{itemize}

\end{itemize}

\item {} 
Fixed
\begin{itemize}
\item {} 
Client
\begin{itemize}
\item {} 
Missing var

\end{itemize}

\item {} 
PackageHandler
\begin{itemize}
\item {} 
Incrementing patch number

\item {} 
Trying to move a file that doesn't exist

\item {} 
Doing migrate on every run

\item {} 
Getting hash of file that doesn't exists

\end{itemize}

\end{itemize}

\end{itemize}


\subsection{v0.12.2 - 2014/12/7}
\label{release_history:v0-12-2-2014-12-7}\begin{itemize}
\item {} 
Updated
\begin{itemize}
\item {} 
PackageHandler
\begin{itemize}
\item {} 
Error reporting when calling methods

\end{itemize}

\end{itemize}

\item {} 
Fixed
\begin{itemize}
\item {} 
CLI scripts

\end{itemize}

\item {} 
Removed
\begin{itemize}
\item {} 
Some unused code

\end{itemize}

\end{itemize}


\subsection{v0.12.1 - 2014/12/4}
\label{release_history:v0-12-1-2014-12-4}\begin{itemize}
\item {} 
Fixed
\begin{itemize}
\item {} 
Migrating to new patch numbering system

\end{itemize}

\end{itemize}


\subsection{v0.12.0 - 2014/11/29}
\label{release_history:v0-12-0-2014-11-29}\begin{itemize}
\item {} 
Added
\begin{itemize}
\item {} 
.pyiupdater data directory. Used to keep track of packages \& patch numbers.

\end{itemize}

\item {} 
Updated
\begin{itemize}
\item {} 
PackageHandler
\begin{itemize}
\item {} 
Will migrate packages in files directory to safe-to-remove folder.
Now only the most recent package will be kept in files directory for patch creation

\end{itemize}

\end{itemize}

\item {} 
Fixed
\begin{itemize}
\item {} 
Install from setup.py

\item {} 
Failed password retry

\end{itemize}

\item {} 
Removed

\end{itemize}


\subsection{v0.11.0 - 2014/11/22}
\label{release_history:v0-11-0-2014-11-22}\begin{itemize}
\item {} 
Added
\begin{itemize}
\item {} 
PyiWrapper
\begin{itemize}
\item {} 
Spec file support. Spec file will be rejected if onedir mode is specified.

\end{itemize}

\end{itemize}

\item {} 
Updated
\begin{itemize}
\item {} 
Client
\begin{itemize}
\item {} 
Now each call to update\_check returns 1 of 2 update objects. AppUpdate or LibUpdate. The updated objects are nearly identical. The AppUpdate object has a few more methods like restart \& extract\_restart. Now instead of calling client.download() you will use app\_update.download(). Check the demos for more info.

\end{itemize}

\item {} 
PyiWrapper
\begin{itemize}
\item {} 
Increased stability of wrapper to better parse args

\end{itemize}

\item {} 
CLI
\begin{itemize}
\item {} 
start cli with pyiupdater-cli instead of pyi-cli

\end{itemize}

\end{itemize}

\item {} 
Removed
\begin{itemize}
\item {} 
CLI
\begin{itemize}
\item {} 
Archiver Utility

\end{itemize}

\end{itemize}

\end{itemize}


\subsection{v0.10.0 - 2014/11/16}
\label{release_history:v0-10-0-2014-11-16}\begin{itemize}
\item {} 
Added
\begin{itemize}
\item {} 
Secure downloading of manifest

\item {} 
Offline update
\begin{itemize}
\item {} 
Upon successful online version manifest signature verification, the version file manifest will be written to the app data folder.

\item {} 
Calls to client.download() will check if update has already been downloaded \& return True if the checksum verifies before attempting to download update.

\end{itemize}

\item {} 
Pyinstaller wrapper
\begin{itemize}
\item {} 
Using the following command compiles your script and archives it ready for file diff and upload:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} pyiupdater app.py \PYGZhy{}\PYGZhy{}app\PYGZhy{}name=APP \PYGZhy{}\PYGZhy{}app\PYGZhy{}version=0.1.0
\end{Verbatim}

\end{itemize}

\item {} 
Deprecated Warnings
\begin{itemize}
\item {} 
use client.extract() instead of client.install()

\item {} 
use client.extract\_restart() instead of client.install\_restart()

\end{itemize}

\end{itemize}

\item {} 
Updated
\begin{itemize}
\item {} 
URL sanitizing
\begin{itemize}
\item {} 
Better handling of types passed to config class attributes

\end{itemize}

\end{itemize}

\item {} 
Fixed
\begin{itemize}
\item {} 
Archiving currently running app
\begin{itemize}
\item {} 
Will now archive Mac.app apps

\end{itemize}

\end{itemize}

\item {} 
Removed
\begin{itemize}
\item {} 
Common util functions
\begin{itemize}
\item {} 
They were added to jms-utils

\end{itemize}

\end{itemize}

\end{itemize}


\subsection{v0.9.2 - 2014/10/19}
\label{release_history:v0-9-2-2014-10-19}\begin{itemize}
\item {} 
Fixed
\begin{itemize}
\item {} 
Require PyInstaller 2.1.1 for PyiUpdater usage

\end{itemize}

\end{itemize}


\subsection{v0.9.1 - 2014/10/19}
\label{release_history:v0-9-1-2014-10-19}\begin{itemize}
\item {} 
Added
\begin{itemize}
\item {} 
Require PyInstaller 2.1.1 for PyiUpdater usage

\end{itemize}

\end{itemize}


\subsection{v0.9.0 - 2014/10/18}
\label{release_history:v0-9-0-2014-10-18}\begin{itemize}
\item {} 
Added
\begin{itemize}
\item {} 
Support for multiple update urls

\item {} 
Auto generated client config

\item {} 
ed25529 Update verification
\begin{itemize}
\item {} 
Using instead of RSA

\end{itemize}

\end{itemize}

\item {} 
Updated
\begin{itemize}
\item {} 
Client updater
\begin{itemize}
\item {} 
Support Mac GUI app bundles

\item {} 
Better error handling

\item {} 
Less failed application execution when updater
has errors

\item {} 
Patcher
\begin{itemize}
\item {} 
Now verifies patched update integrity
against version file

\end{itemize}

\end{itemize}

\item {} 
Downloader
\begin{itemize}
\item {} 
Https verification
\begin{itemize}
\item {} 
on by default

\item {} 
Can disable in config file

\item {} 
VERIFY\_SERVER\_CERT

\end{itemize}

\item {} 
Dynamic block resizing

\end{itemize}

\item {} 
Archive Extraction
\begin{itemize}
\item {} 
More reliable

\end{itemize}

\item {} 
Archive creator
\begin{itemize}
\item {} 
Works with mac GUI apps

\end{itemize}

\item {} 
Private methods
\begin{itemize}
\item {} 
Refactored to make testing easier

\end{itemize}

\end{itemize}

\end{itemize}


\subsection{v0.8.1 - 2014/9/3}
\label{release_history:v0-8-1-2014-9-3}\begin{itemize}
\item {} 
Added
\begin{itemize}
\item {} 
jms-utils

\end{itemize}

\item {} 
Fixed
\begin{itemize}
\item {} 
Packaging setup.py installation

\end{itemize}

\item {} 
Removed
\begin{itemize}
\item {} 
Unused tests

\end{itemize}

\end{itemize}


\subsection{v0.8.0 - 2014/8/31}
\label{release_history:v0-8-0-2014-8-31}\begin{itemize}
\item {} 
Added
\begin{itemize}
\item {} 
Archive Maker utility
\begin{itemize}
\item {} 
Makes zip \& gzip archives with name, version
and platform in correct format for package handler

\end{itemize}

\item {} 
Signals
\begin{itemize}
\item {} 
If you want to run updater in background
thread you can subscribe to signals for
download progress and completion

\end{itemize}

\item {} 
CLI
\begin{itemize}
\item {} 
Option to change encryption password

\end{itemize}

\item {} 
Initial py3 compat

\item {} 
More code comments if you want to get your
hands dirty

\item {} 
Option to enable https verification

\end{itemize}

\item {} 
Updated
\begin{itemize}
\item {} 
Package Handler
\begin{itemize}
\item {} 
Package metadata parsing is faster. Thanks
to a new \& shiny package object.

\end{itemize}

\item {} 
File Crypt
\begin{itemize}
\item {} 
Uses simple encryption interface of
simple-crypt. Pycrypto in background.

\end{itemize}

\end{itemize}

\item {} 
Fixed
\begin{itemize}
\item {} 
CLI
\begin{itemize}
\item {} 
Initial setup didn't save settings
to correct class attributes

\end{itemize}

\item {} 
Client
\begin{itemize}
\item {} 
Parsing of version file

\end{itemize}

\item {} 
Patch creation
\begin{itemize}
\item {} 
Example:

1.9 \textgreater{} 1.10 was True

1.9 \textgreater{} 1.10 is now False

\end{itemize}

\end{itemize}

\item {} 
Removed
\begin{itemize}
\item {} 
Cryptography dependency

\item {} 
License text from individual files

\item {} 
Unused imports

\end{itemize}

\end{itemize}


\subsection{v0.7.2 - 2014/8/10}
\label{release_history:v0-7-2-2014-8-10}\begin{itemize}
\item {} 
Fixed
\begin{itemize}
\item {} 
Error on load cli

\end{itemize}

\end{itemize}


\subsection{v0.7.1 - 2014/8/10}
\label{release_history:v0-7-1-2014-8-10}\begin{itemize}
\item {} 
Added
\begin{itemize}
\item {} 
Utils
\begin{itemize}
\item {} 
Utils specific errors

\end{itemize}

\item {} 
KeyHandler
\begin{itemize}
\item {} 
Error if DevDataDir not setup

\end{itemize}

\end{itemize}

\item {} 
Updated
\begin{itemize}
\item {} 
Client
\begin{itemize}
\item {} 
Better parsing of old updates to remove

\item {} 
More error checking

\item {} 
More error reporting

\item {} 
Dynamic creation of archive format

\end{itemize}

\item {} 
Utils
\begin{itemize}
\item {} 
Better parsing of dot files for removal

\end{itemize}

\end{itemize}

\item {} 
Removed
\begin{itemize}
\item {} 
Client
\begin{itemize}
\item {} 
Some old transition code

\end{itemize}

\end{itemize}

\end{itemize}


\subsection{v0.7 - 2014/8/3}
\label{release_history:v0-7-2014-8-3}\begin{itemize}
\item {} 
Added
\begin{itemize}
\item {} 
Uploader plugin support

\item {} 
Default S3 \& SCP plugins

\item {} 
Support for gzipped archives

\end{itemize}

\item {} 
Updated
\begin{itemize}
\item {} 
Menu option handling

\end{itemize}

\item {} 
Remove
\begin{itemize}
\item {} 
Upload code for s3 and scp

\item {} 
Unused config options

\item {} 
Redundant upload checks

\end{itemize}

\end{itemize}


\subsection{v0.6.0 - 2014/7/27}
\label{release_history:v0-6-0-2014-7-27}
\textbf{* Renamed to PyiUpdater *}
\begin{itemize}
\item {} 
Removed
\begin{itemize}
\item {} 
Old transition code

\item {} 
Binary support
\begin{itemize}
\item {} 
only pip \& src install

\end{itemize}

\end{itemize}

\end{itemize}


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{p}
\item {\texttt{pyi\_updater}}, \pageref{api:module-pyi_updater}
\item {\texttt{pyi\_updater.client}}, \pageref{api:module-pyi_updater.client}
\item {\texttt{pyi\_updater.client.updates}}, \pageref{api:module-pyi_updater.client.updates}
\item {\texttt{pyi\_updater.client.utils}}, \pageref{api:module-pyi_updater.client.utils}
\item {\texttt{pyi\_updater.config}}, \pageref{api:module-pyi_updater.config}
\item {\texttt{pyi\_updater.downloader}}, \pageref{api:module-pyi_updater.downloader}
\item {\texttt{pyi\_updater.exceptions}}, \pageref{api:module-pyi_updater.exceptions}
\item {\texttt{pyi\_updater.key\_handler}}, \pageref{api:module-pyi_updater.key_handler}
\item {\texttt{pyi\_updater.package\_handler}}, \pageref{api:module-pyi_updater.package_handler}
\item {\texttt{pyi\_updater.package\_handler.package}}, \pageref{api:module-pyi_updater.package_handler.package}
\item {\texttt{pyi\_updater.patcher}}, \pageref{api:module-pyi_updater.patcher}
\item {\texttt{pyi\_updater.uploader}}, \pageref{api:module-pyi_updater.uploader}
\item {\texttt{pyi\_updater.uploader.common}}, \pageref{api:module-pyi_updater.uploader.common}
\item {\texttt{pyi\_updater.utils}}, \pageref{api:module-pyi_updater.utils}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
